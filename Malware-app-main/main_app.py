import customtkinter as ctk
from PIL import Image
from tkinter import filedialog, messagebox
import json
import os
import sys
import threading
import time
import hashlib
import requests
import pefile
from quicksand.quicksand import quicksand


VT_API_KEY = "0b3ec7bc013f9a13f623c7d027ffbd543d13f7e540b71121a9109597b3c52caa"
VT_API_URL = "https://www.virustotal.com/api/v3/files/"
SCRIPT_VERSION = "3.0"


def calcular_hashes(filepath):
    """Calcula MD5, SHA1, SHA256 y SHA512 de un archivo."""
    hashes = {
        "md5": hashlib.md5(),
        "sha1": hashlib.sha1(),
        "sha256": hashlib.sha256(),
        "sha512": hashlib.sha512(),
    }
    try:
        with open(filepath, "rb") as f:
            while True:
                chunk = f.read(8192)
                if not chunk:
                    break
                for h in hashes.values():
                    h.update(chunk)
        return {name: h.hexdigest() for name, h in hashes.items()}
    except Exception:
        return None


def consultar_virustotal(sha256, status_callback):
    status_callback("Consultando VirusTotal...")
    if VT_API_KEY == "TU_API_KEY_DE_VIRUSTOTAL_AQUI":
        return {"error": "API Key de VirusTotal no configurada."}
    headers = {"x-apikey": VT_API_KEY}
    try:
        response = requests.get(VT_API_URL + sha256, headers=headers, timeout=20)
        if response.status_code == 200:
            data = response.json().get("data", {}).get("attributes", {})
            stats = data.get("last_analysis_stats", {})
            malicious_vendors = []
            last_analysis_results = data.get("last_analysis_results", {})
            for vendor, result in last_analysis_results.items():
                if result.get("category") == "malicious":
                    malicious_vendors.append(
                        {
                            "vendor": vendor,
                            "result": result.get("result", ""),
                            "engine_name": result.get("engine_name", vendor),
                        }
                    )
            return {
                "malicious_detections": stats.get("malicious", 0),
                "total_scans": sum(stats.values()),
                "names": data.get("names", []),
                "meaningful_name": data.get("meaningful_name"),
                "type_tag": data.get("type_tag"),
                "signature_info": data.get("signature_info"),
                "times_submitted": data.get("times_submitted"),
                "popular_threat_classification": data.get(
                    "popular_threat_classification"
                ),
                "trid": data.get("trid"),
                "exiftool": data.get("exiftool"),
                "tags": data.get("tags"),
                "malicious_vendors": malicious_vendors,
            }
        elif response.status_code == 404:
            return {"error": "Hash no encontrado en VirusTotal."}
        else:
            return {"error": f"Error en API (C칩digo: {response.status_code})"}
    except Exception as e:
        return {"error": f"No se pudo conectar a VirusTotal: {e}"}


def analizar_pe(filepath, status_callback):
    status_callback("Analizando imports del ejecutable...")
    num_imports, file_version = 0, "N/A"
    imports_grouped = {}
    try:
        pe = pefile.PE(filepath)
        # Recolectar imports detallados (dll -> lista de funciones), incluyendo ordinales
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = (
                    entry.dll.decode(errors="ignore")
                    if isinstance(entry.dll, (bytes, bytearray))
                    else str(entry.dll)
                )
                funcs = []
                for imp in entry.imports:
                    if imp.name:
                        func_name = (
                            imp.name.decode(errors="ignore")
                            if isinstance(imp.name, (bytes, bytearray))
                            else str(imp.name)
                        )
                    else:
                        func_name = f"ORDINAL_{imp.ordinal}"  # Importaci칩n por ordinal
                    funcs.append(func_name)
                num_imports += len(funcs)
                imports_grouped[dll_name] = funcs
        # Intentar obtener versi칩n del archivo
        if hasattr(pe, "VS_VERSIONINFO") and hasattr(pe, "VS_FIXEDFILEINFO"):
            for fileinfo in pe.VS_VERSIONINFO:
                if fileinfo.Key == b"VS_FIXEDFILEINFO":
                    ver_info = pe.VS_FIXEDFILEINFO[0]
                    file_version = f"{ver_info.FileVersionMS >> 16}.{ver_info.FileVersionMS & 0xFFFF}.{ver_info.FileVersionLS >> 16}.{ver_info.FileVersionLS & 0xFFFF}"
                    break
    except pefile.PEFormatError:
        return {
            "type": "Desconocido",
            "num_imports": 0,
            "file_version": "N/A",
            "imports": {},
        }
    except Exception:
        return {"type": "Error", "num_imports": 0, "file_version": "N/A", "imports": {}}
    return {
        "type": "Archivo PE de Windows (exe/dll)",
        "num_imports": num_imports,
        "file_version": file_version,
        "imports": imports_grouped,
    }


def generar_veredicto(vt_results):
    detections = vt_results.get("malicious_detections", 0)
    if detections > 5:
        return {
            "texto": "游댮 POTENCIALMENTE PELIGROSO",
            "color": "red",
            "riesgo": "Alto",
        }
    elif 1 < detections <= 5:
        return {
            "texto": "游댮 POTENCIALMENTE PELIGROSO",
            "color": "red",
            "riesgo": "Medio-Alto",
        }
    elif detections > 0:
        return {
            "texto": "游 POTENCIAL FALSO POSITIVO",
            "color": "orange",
            "riesgo": "Bajo",
        }
    else:
        return {
            "texto": "游릭 PROBABLEMENTE SEGURO",
            "color": "green",
            "riesgo": "Muy Bajo",
        }


def format_file_report(data):
    summary = data.get("analysis_summary", {})
    verdict = summary.get("risk_verdict", {})
    report = [
        f"--- VEREDICTO: {verdict.get('texto', 'N/A')} ---",
        "\n--- RESUMEN DEL AN츼LISIS ---",
        f"Score (Detecciones VT): {summary.get('score', 'N/A')}",
        f"Warnings (Imports sospechosos): {summary.get('warnings', 'N/A')}",
        "\n--- INFORMACI칍N DEL ARCHIVO ---",
        f"Filename: {data.get('filename', 'N/A')}",
        f"Size: {data.get('size_bytes', 0)} bytes ({data.get('size_kb', 0.0):.2f} KB)",
        f"Type: {data.get('type', 'N/A')}",
        f"Header (primeros 32 bytes): {data.get('header', 'N/A')}",
        f"Nombre representativo: {data.get('meaningful_name', 'N/A')}",
        f"Tipo de archivo (type_tag): {data.get('type_tag', 'N/A')}",
        f"Firma digital: {data.get('signature_info', 'N/A')}",
        f"Veces enviado a VT: {data.get('times_submitted', 'N/A')}",
    ]
    ptc = data.get("popular_threat_classification", {})
    threat = (
        ptc.get("suggested_threat_label", "N/A")
        if ptc and isinstance(ptc, dict)
        else "N/A"
    )
    report.extend(
        [
            f"Clasificaci칩n de amenaza: {threat}",
            f"TRiD: {data.get('trid', 'N/A')}",
            f"ExifTool: {data.get('exiftool', 'N/A')}",
            f"Etiquetas: {', '.join(data.get('tags', [])) if data.get('tags') else 'N/A'}",
            "\n--- HASHES ---",
            f"MD5:    {data.get('md5', 'N/A')}",
            f"SHA1:   {data.get('sha1', 'N/A')}",
            f"SHA256: {data.get('sha256', 'N/A')}",
            f"SHA512: {data.get('sha512', 'N/A')}",
        ]
    )
    malicious_vendors = data.get("malicious_vendors", [])
    if malicious_vendors:
        report.append("\n--- DETECCIONES DE PROVEEDORES ---")
        for v in malicious_vendors:
            report.append(f"- {v.get('vendor', 'N/A')}: {v.get('result', 'N/A')}")
    timing = data.get("timing", {})
    report.extend(
        [
            "\n--- METADATOS DEL AN츼LISIS ---",
            f"Versi칩n del Script: {data.get('version', 'N/A')}",
            f"An치lisis iniciado: {time.ctime(timing.get('started', 0))}",
            f"An치lisis finalizado: {time.ctime(timing.get('finished', 0))}",
            f"Tiempo transcurrido: {timing.get('elapsed', 0.0):.4f} segundos",
        ]
    )
    # Secci칩n opcional de imports PE detallados
    imports_grouped = data.get("imports")
    if imports_grouped and isinstance(imports_grouped, dict) and imports_grouped.keys():
        report.append("\n--- IMPORTS (PE) ---")
        for dll, funcs in imports_grouped.items():
            report.append(f"{dll} ({len(funcs)}):")
            for fn in funcs:
                report.append(f"  - {fn}")
    return "\n".join(report)


def resource_path(relative_path):
    base_path = getattr(
        sys,
        "_MEIPASS",
        os.path.abspath(os.path.join(os.path.dirname(__file__), "icons")),
    )
    return os.path.join(base_path, relative_path)


class SelectionFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color="transparent")
        self.master = master
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")

        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(
            relx=0.5, rely=0.1, relwidth=0.2, relheight=0.2, anchor="center"
        )

        self.title = ctk.CTkLabel(
            self,
            text="Seleccione el tipo de an치lisis",
            font=ctk.CTkFont(size=24, weight="bold"),
        )
        self.title.place(relx=0.5, rely=0.3, anchor="center")

        self.btn_doc = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar Documento\n (.docx,.pdf,.xlsx)",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=master.show_doc_entry_frame,
        )
        self.btn_doc.place(
            relx=0.5, rely=0.5, relwidth=0.4, relheight=0.2, anchor="center"
        )

        self.btn_file = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar Archivo \n (.exe,.zip,.bin)",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=master.show_file_entry_frame,
        )
        self.btn_file.place(
            relx=0.5, rely=0.8, relwidth=0.4, relheight=0.2, anchor="center"
        )


class FileEntryFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")
        self.file_path = ""
        self.volver_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("go_back.png")),
            dark_image=Image.open(resource_path("go_back(1).png")),
            size=(60, 40),
        )
        self.folder_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("favicon.ico")),
            dark_image=Image.open(resource_path("favicon.ico")),
        )
        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.entry_variable = ctk.StringVar(
            value="Inserte la ruta de un archivo o presione el bot칩n para buscarlo..."
        )
        self.entry = ctk.CTkEntry(
            self, textvariable=self.entry_variable, border_width=1
        )
        self.button = ctk.CTkButton(
            self,
            image=self.folder_pic,
            text="",
            command=self.file_searching,
            width=50,
            border_width=1,
            fg_color=("#FF0000", "#FFFFFF"),
            hover_color=("#a10101", "#030227"),
        )
        self.file_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar...",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.start_analysis,
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.status_label = ctk.CTkLabel(self, text="", text_color=("blue", "cyan"))

        self.back_button = ctk.CTkButton(
            self,
            text="",
            image=self.volver_pic,
            command=master.show_selection_frame,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(relx=0.5, rely=0.2, anchor="center")
        self.entry.place(relx=0.05, rely=0.5, relwidth=0.8, relheight=0.1, anchor="w")
        self.button.place(relx=0.95, rely=0.5, relwidth=0.1, relheight=0.1, anchor="e")
        self.file_button.place(
            relx=0.5, rely=0.7, relwidth=0.2, relheight=0.15, anchor="center"
        )
        self.status_label.place(relx=0.5, rely=0.95, anchor="center")
        self.back_button.place(relx=0.01, rely=0.01, anchor="nw")

    def file_searching(self):
        self.file_path = filedialog.askopenfilename(
            title="Seleccionar archivo para an치lisis",
            filetypes=(
                ("Archivos Soportados", "*.exe *.dll *.zip *.rar *.7z"),
                ("Todos los archivos", "*.*"),
            ),
        )
        if self.file_path:
            self.entry_variable.set(self.file_path)
        else:
            self.entry_variable.set("No se seleccion칩 ning칰n archivo")

    def start_analysis(self):
        if not self.file_path or not os.path.exists(self.file_path):
            self.entry_variable.set("Por favor, seleccione un archivo v치lido.")
            return
        self.file_button.configure(state="disabled")
        self.button.configure(state="disabled")
        self.status_label.configure(text="Analizando, por favor espere...")
        self.master.start_file_analysis_thread(self.file_path)


class FileResultsFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=2, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.results = results
        self.place(relx=0.5, rely=0.5, relwidth=0.6, relheight=0.8, anchor="center")
        veredicto = self.results.get("analysis_summary", {}).get("risk_verdict", {})
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=2)
        ctk.CTkLabel(
            self,
            text="Resultados del Archivo",
            font=ctk.CTkFont(size=20, weight="bold"),
        ).grid(row=0, column=0, columnspan=2, pady=10, sticky="n")
        labels = [
            "Nombre del archivo:",
            "Tipo de archivo:",
            "Firma digital:",
            "Versi칩n del archivo:",
            "Riesgo:",
            "Score de VirusTotal:",
        ]
        signature_info = self.results.get("signature_info")
        firma = (
            f"S칤 (Autor: {signature_info.get('signers')})"
            if signature_info
            and isinstance(signature_info, dict)
            and signature_info.get("signers")
            else "No"
        )
        vt_score = self.results.get("analysis_summary", {}).get("score", 0)
        total_scans = self.results.get("total_scans", "N/A")
        values = [
            self.results.get("filename", "N/A"),
            self.results.get("type", "N/A"),
            firma,
            self.results.get("file_version", "N/A"),
            veredicto.get("riesgo", "N/A"),
            f"{vt_score}/{total_scans}",
        ]
        for i, (label, value) in enumerate(zip(labels, values)):
            ctk.CTkLabel(self, text=label, anchor="w").grid(
                row=i + 1, column=0, padx=20, pady=5, sticky="ew"
            )
            ctk.CTkLabel(self, text=value, anchor="w").grid(
                row=i + 1, column=1, padx=20, pady=5, sticky="ew"
            )
        ctk.CTkLabel(self, text="Detecciones de VirusTotal:", anchor="w").grid(
            row=7, column=0, padx=20, pady=(10, 0), sticky="ew"
        )
        detections_text = ctk.CTkTextbox(
            self,
            height=100,
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        detections_text.grid(
            row=8, column=0, columnspan=2, padx=20, pady=5, sticky="ew"
        )
        malicious_vendors = self.results.get("malicious_vendors", [])
        if malicious_vendors:
            for v in malicious_vendors:
                detections_text.insert(
                    "end", f"- {v.get('vendor', 'N/A')}: {v.get('result', 'N/A')}\n"
                )
        else:
            detections_text.insert("end", "0")
        detections_text.configure(state="disabled")
        self.grid_rowconfigure(9, weight=1)
        self.detail_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="An치lisis detallado",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.show_details,
        )
        self.refresh_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.detail_button.place(
            relx=0.3, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )
        self.refresh_button.place(
            relx=0.7, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )

    def show_details(self):
        self.destroy()
        self.master.show_detailed_file_frame(self.results)

    def refresh(self):
        self.destroy()
        self.master.show_file_entry_frame()


class DetailedFileFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=0, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.results = results
        self.place(relx=0.5, rely=0.5, relwidth=0.7, relheight=0.8, anchor="center")
        self.textbox = ctk.CTkTextbox(
            self,
            wrap="word",
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        self.textbox.pack(padx=10, pady=10, fill="both", expand=True)
        self.textbox.insert("0.0", format_file_report(self.results))
        self.textbox.configure(state="disabled")
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(fill="x", pady=10)
        self.txt_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar an치lisis a txt",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_txt,
        )
        self.json_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar an치lisis a json",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_json,
        )
        self.refresh_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.txt_button.pack(side="left", expand=True)
        self.json_button.pack(side="left", expand=True)
        self.refresh_button.pack(side="left", expand=True)

    def save_report(self, formato):
        if formato == "JSON":
            file_ext, file_types, content = (
                ".json",
                [("JSON files", "*.json")],
                json.dumps(self.results, indent=4, ensure_ascii=False),
            )
        else:
            file_ext, file_types, content = (
                ".txt",
                [("Text files", "*.txt")],
                format_file_report(self.results),
            )

        initial_filename = os.path.splitext(self.results["filename"])[0]

        save_path = filedialog.asksaveasfilename(
            initialfile=f"reporte_{initial_filename}",
            defaultextension=file_ext,
            filetypes=file_types,
        )
        if save_path:
            try:
                with open(save_path, "w", encoding="utf-8") as f:
                    f.write(content)
                messagebox.showinfo("칄xito", f"Reporte guardado en:\n{save_path}")
            except Exception as e:
                messagebox.showerror(
                    "Error al guardar", f"No se pudo guardar el archivo:\n{e}"
                )

    def save_txt(self):
        self.save_report("TXT")

    def save_json(self):
        self.save_report("JSON")

    def refresh(self):
        self.destroy()
        self.master.show_file_entry_frame()


# --- Clases de malware_app.py adaptadas ---
class DocEntryFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")
        self.file_path = ""
        self.volver_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("go_back.png")),
            dark_image=Image.open(resource_path("go_back(1).png")),
            size=(60, 40),
        )
        self.folder_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("favicon.ico")),
            dark_image=Image.open(resource_path("favicon.ico")),
        )
        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.entry_variable = ctk.StringVar(
            value="Inserte la ruta de un documento o presione el bot칩n para buscarlo..."
        )
        self.entry = ctk.CTkEntry(
            self, textvariable=self.entry_variable, border_width=1
        )

        self.button = ctk.CTkButton(
            self,
            image=self.folder_pic,
            text="",
            command=self.file_searching,
            width=50,
            border_width=1,
            fg_color=("#FF0000", "#FFFFFF"),
            hover_color=("#a10101", "#030227"),
        )
        self.file_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar...",
            border_width=2,
            command=self.next_frame,
            hover_color=("#a10101", "#030227"),
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.back_button = ctk.CTkButton(
            self,
            text="",
            image=self.volver_pic,
            command=master.show_selection_frame,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(relx=0.5, rely=0.2, anchor="center")
        self.entry.place(relx=0.05, rely=0.5, relwidth=0.8, relheight=0.1, anchor="w")
        self.button.place(relx=0.95, rely=0.5, relwidth=0.1, relheight=0.1, anchor="e")
        self.file_button.place(
            relx=0.5, rely=0.7, relwidth=0.2, relheight=0.15, anchor="center"
        )
        self.back_button.place(relx=0.01, rely=0.01, anchor="nw")

    def file_searching(self):
        self.file_path = filedialog.askopenfilename(
            title="Select a file",
            filetypes=[
                ("Documentos de Word", "*.docx"),
                ("Documentos pdf", "*.pdf"),
                ("Documentos excel", "*xlsx"),
                ("Todos los archivos", "*.*"),
            ],
        )
        if self.file_path:
            self.entry_variable.set(self.file_path)
        else:
            self.entry_variable.set("No se seleccion칩 ning칰n archivo")

    def next_frame(self):
        if self.file_path:
            self.destroy()
            self.master.show_doc_results_frame(self.file_path)
        else:
            self.entry_variable.set("No se seleccion칩 ning칰n archivo")


class DocResultsFrame(ctk.CTkFrame):
    def __init__(self, master, filepath):
        super().__init__(master, border_width=2, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.5, relheight=0.8, anchor="center")
        self.qs = quicksand(filepath)
        self.qs.process()
        self.qs.results["filename"] = os.path.basename(filepath)
        ctk.CTkLabel(
            self,
            text="Resultados del Documento",
            font=ctk.CTkFont(size=20, weight="bold"),
        ).place(relx=0.05, rely=0.05, anchor="nw")
        labels = [
            "Nombre del archivo:",
            "Riesgo:",
            "Advertencias:",
            "Tama침o del archivo:",
        ]
        values = [
            self.qs.results["filename"],
            self.qs.results["risk"],
            self.qs.results["warning"],
            f"{self.qs.results['size']} bytes",
        ]
        for i, (label, value) in enumerate(zip(labels, values)):
            ctk.CTkLabel(self, text=label).place(
                relx=0.05, rely=0.15 + i * 0.1, anchor="nw"
            )
            ctk.CTkLabel(self, text=value).place(
                relx=0.4, rely=0.15 + i * 0.1, anchor="nw"
            )
        self.button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="An치lisis detallado",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.analisis,
        )
        self.button.place(
            relx=0.25, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )
        self.refresh_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.refresh_button.place(
            relx=0.7, rely=0.7, relwidth=0.32, relheight=0.1, anchor="center"
        )

    def analisis(self):
        self.destroy()
        self.master.show_detailed_doc_frame(self.qs.results)

    def refresh(self):
        self.destroy()
        self.master.show_doc_entry_frame()


class DetailedDocFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=0, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.7, relheight=0.8, anchor="center")
        self.results = results

        self.textbox = ctk.CTkTextbox(
            self,
            wrap="word",
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        self.textbox.pack(padx=10, pady=10, fill="both", expand=True)
        self.textbox.insert("0.0", json.dumps(self.results, indent=4))
        self.textbox.configure(state="disabled")
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(fill="x", pady=10)
        self.txt_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar an치lisis a txt",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_txt,
        )
        self.json_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar an치lisis a json",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_json,
        )
        self.refresh_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.txt_button.pack(side="left", expand=True)
        self.json_button.pack(side="left", expand=True)
        self.refresh_button.pack(side="left", expand=True)

    def save_report(self, formato):
        content = json.dumps(self.results, indent=4)
        file_ext = ".json" if formato == "JSON" else ".txt"
        file_types = (
            [("JSON files", "*.json")]
            if formato == "JSON"
            else [("Text files", "*.txt")]
        )

        initial_filename = os.path.splitext(self.results["filename"])[0]

        save_path = filedialog.asksaveasfilename(
            initialfile=f"reporte_{initial_filename}",
            defaultextension=file_ext,
            filetypes=file_types,
        )
        if save_path:
            try:
                with open(save_path, "w", encoding="utf-8") as f:
                    f.write(content)
                messagebox.showinfo("칄xito", f"Reporte guardado en:\n{save_path}")
            except Exception as e:
                messagebox.showerror(
                    "Error al guardar", f"No se pudo guardar el archivo:\n{e}"
                )

    def save_txt(self):
        self.save_report("TXT")

    def save_json(self):
        self.save_report("JSON")

    def refresh(self):
        self.destroy()
        self.master.show_doc_entry_frame()


class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Analizador de Malware")
        self.geometry("900x700")
        self.configure(fg_color=("#ffffff", "#02005C"))
        self.iconbitmap(resource_path("logo.ico"))
        self.current_frame = None

        # --- Botones de la ventana principal ---
        self.theme_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("sun.ico")),
            dark_image=Image.open(resource_path("moon.ico")),
        )
        self.logo_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.ico")),
            dark_image=Image.open(resource_path("logo2.ico")),
        )

        self.theme_button = ctk.CTkButton(
            self,
            width=0.1,
            height=0.2,
            text="",
            image=self.theme_pic,
            compound="left",
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
            command=self.change_theme,
        )
        self.theme_button.place(
            relx=1, rely=0, relwidth=0.05, relheight=0.05, anchor="ne"
        )

        self.logo_button = ctk.CTkButton(
            self,
            width=0.1,
            height=0.2,
            text="",
            image=self.logo_pic,
            compound="left",
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.logo_button.place(
            relx=0, rely=0, relwidth=0.05, relheight=0.05, anchor="nw"
        )

        self.show_selection_frame()

    def change_theme(self):
        if ctk.get_appearance_mode() == "Light":
            ctk.set_appearance_mode("Dark")
            self.iconbitmap(resource_path("logo2.ico"))
        else:
            ctk.set_appearance_mode("Light")
            self.iconbitmap(resource_path("logo.ico"))

    def clear_frame(self):
        for widget in self.winfo_children():
            if isinstance(
                widget,
                (
                    SelectionFrame,
                    FileEntryFrame,
                    DocEntryFrame,
                    FileResultsFrame,
                    DocResultsFrame,
                    DetailedFileFrame,
                    DetailedDocFrame,
                ),
            ):
                widget.destroy()
        if self.current_frame:
            self.current_frame.destroy()
            self.current_frame = None

    def show_selection_frame(self):
        self.clear_frame()
        self.current_frame = SelectionFrame(self)

    def show_file_entry_frame(self):
        self.clear_frame()
        self.current_frame = FileEntryFrame(self)

    def show_doc_entry_frame(self):
        self.clear_frame()
        self.current_frame = DocEntryFrame(self)

    def show_file_results_frame(self, results):
        self.clear_frame()
        self.current_frame = FileResultsFrame(self, results)

    def show_doc_results_frame(self, filepath):
        self.clear_frame()
        self.current_frame = DocResultsFrame(self, filepath)

    def show_detailed_file_frame(self, results):
        self.clear_frame()
        self.current_frame = DetailedFileFrame(self, results)

    def show_detailed_doc_frame(self, results):
        self.clear_frame()
        self.current_frame = DetailedDocFrame(self, results)

    def start_file_analysis_thread(self, filepath):
        thread = threading.Thread(target=self.run_file_analysis, args=(filepath,))
        thread.daemon = True
        thread.start()

    def run_file_analysis(self, filepath):
        start_time = time.time()
        try:
            all_hashes = calcular_hashes(filepath)
            if not all_hashes:
                raise Exception("No se pudieron calcular los hashes.")
            with open(filepath, "rb") as f:
                header_hex = f.read(32).hex()
            vt_results = consultar_virustotal(all_hashes["sha256"], lambda m: None)
            pe_info = analizar_pe(filepath, lambda m: None)
            veredicto = generar_veredicto(vt_results)
            analysis_result = {
                "filename": os.path.basename(filepath),
                "md5": all_hashes.get("md5"),
                "sha1": all_hashes.get("sha1"),
                "sha256": all_hashes.get("sha256"),
                "sha512": all_hashes.get("sha512"),
                "size_bytes": os.path.getsize(filepath),
                "size_kb": os.path.getsize(filepath) / 1024.0,
                "type": pe_info["type"],
                "file_version": pe_info.get("file_version", "N/A"),
                "num_imports": pe_info.get("num_imports", "N/A"),
                "imports": pe_info.get("imports", {}),
                "header": header_hex,
                "analysis_summary": {
                    "risk_verdict": veredicto,
                    "score": vt_results.get("malicious_detections", "N/A"),
                    "warnings": 0,
                },
                "total_scans": vt_results.get("total_scans", 0),
                **vt_results,
                "timing": {
                    "started": start_time,
                    "finished": time.time(),
                    "elapsed": time.time() - start_time,
                },
                "version": SCRIPT_VERSION,
            }
            self.after(0, self.show_file_results_frame, analysis_result)
        except Exception as e:
            self.after(0, lambda: messagebox.showerror("Error de An치lisis", str(e)))
            self.after(0, self.show_file_entry_frame)


if __name__ == "__main__":
    ctk.set_appearance_mode("System")
    ctk.set_default_color_theme("blue")
    app = App()
    app.mainloop()
