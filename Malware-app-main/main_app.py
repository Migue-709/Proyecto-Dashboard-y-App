import customtkinter as ctk
from PIL import Image
from tkinter import filedialog, messagebox
import json
import os
import sys
import threading
import time
import hashlib
import requests
import pefile
from quicksand.quicksand import quicksand


VT_API_KEY = "0b3ec7bc013f9a13f623c7d027ffbd543d13f7e540b71121a9109597b3c52caa"
VT_API_URL = "https://www.virustotal.com/api/v3/files/"
SCRIPT_VERSION = "3.0"


def calcular_hashes(filepath):
    """Calcula MD5, SHA1, SHA256 y SHA512 de un archivo."""
    hashes = {
        "md5": hashlib.md5(),
        "sha1": hashlib.sha1(),
        "sha256": hashlib.sha256(),
        "sha512": hashlib.sha512(),
    }
    try:
        with open(filepath, "rb") as f:
            while True:
                chunk = f.read(8192)
                if not chunk:
                    break
                for h in hashes.values():
                    h.update(chunk)
        return {name: h.hexdigest() for name, h in hashes.items()}
    except Exception:
        return None


def consultar_virustotal(sha256, status_callback):
    status_callback("Consultando VirusTotal...")
    if VT_API_KEY == "TU_API_KEY_DE_VIRUSTOTAL_AQUI":
        return {"error": "API Key de VirusTotal no configurada."}
    headers = {"x-apikey": VT_API_KEY}
    try:
        response = requests.get(VT_API_URL + sha256, headers=headers, timeout=20)
        if response.status_code == 200:
            data = response.json().get("data", {}).get("attributes", {})
            stats = data.get("last_analysis_stats", {})
            malicious_vendors = []
            last_analysis_results = data.get("last_analysis_results", {})
            for vendor, result in last_analysis_results.items():
                if result.get("category") == "malicious":
                    malicious_vendors.append(
                        {
                            "vendor": vendor,
                            "result": result.get("result", ""),
                            "engine_name": result.get("engine_name", vendor),
                        }
                    )
            return {
                "malicious_detections": stats.get("malicious", 0),
                "total_scans": sum(stats.values()),
                "names": data.get("names", []),
                "meaningful_name": data.get("meaningful_name"),
                "type_tag": data.get("type_tag"),
                "signature_info": data.get("signature_info"),
                "times_submitted": data.get("times_submitted"),
                "popular_threat_classification": data.get(
                    "popular_threat_classification"
                ),
                "trid": data.get("trid"),
                "exiftool": data.get("exiftool"),
                "tags": data.get("tags"),
                "malicious_vendors": malicious_vendors,
            }
        elif response.status_code == 404:
            return {"error": "Hash no encontrado en VirusTotal."}
        else:
            return {"error": f"Error en API (Código: {response.status_code})"}
    except Exception as e:
        return {"error": f"No se pudo conectar a VirusTotal: {e}"}


def analizar_pe(filepath, status_callback):
    status_callback("Analizando imports del ejecutable...")
    num_imports, file_version = 0, "N/A"
    imports_grouped = {}
    try:
        pe = pefile.PE(filepath)
        # Recolectar imports detallados (dll -> lista de funciones), incluyendo ordinales
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = (
                    entry.dll.decode(errors="ignore")
                    if isinstance(entry.dll, (bytes, bytearray))
                    else str(entry.dll)
                )
                funcs = []
                for imp in entry.imports:
                    if imp.name:
                        func_name = (
                            imp.name.decode(errors="ignore")
                            if isinstance(imp.name, (bytes, bytearray))
                            else str(imp.name)
                        )
                    else:
                        func_name = f"ORDINAL_{imp.ordinal}"  # Importación por ordinal
                    funcs.append(func_name)
                num_imports += len(funcs)
                imports_grouped[dll_name] = funcs
        # Intentar obtener versión del archivo
        if hasattr(pe, "VS_VERSIONINFO") and hasattr(pe, "VS_FIXEDFILEINFO"):
            for fileinfo in pe.VS_VERSIONINFO:
                if fileinfo.Key == b"VS_FIXEDFILEINFO":
                    ver_info = pe.VS_FIXEDFILEINFO[0]
                    file_version = f"{ver_info.FileVersionMS >> 16}.{ver_info.FileVersionMS & 0xFFFF}.{ver_info.FileVersionLS >> 16}.{ver_info.FileVersionLS & 0xFFFF}"
                    break
    except pefile.PEFormatError:
        return {
            "type": "Desconocido",
            "num_imports": 0,
            "file_version": "N/A",
            "imports": {},
        }
    except Exception:
        return {"type": "Error", "num_imports": 0, "file_version": "N/A", "imports": {}}
    return {
        "type": "Archivo PE de Windows (exe/dll)",
        "num_imports": num_imports,
        "file_version": file_version,
        "imports": imports_grouped,
    }


def generar_veredicto(vt_results):
    detections = vt_results.get("malicious_detections", 0)
    if detections > 5:
        return {
            "texto": "🔴 POTENCIALMENTE PELIGROSO",
            "color": "red",
            "riesgo": "Alto",
        }
    elif 1 < detections <= 5:
        return {
            "texto": "🔴 POTENCIALMENTE PELIGROSO",
            "color": "red",
            "riesgo": "Medio-Alto",
        }
    elif detections > 0:
        return {
            "texto": "🟠 POTENCIAL FALSO POSITIVO",
            "color": "orange",
            "riesgo": "Bajo",
        }
    else:
        return {
            "texto": "🟢 PROBABLEMENTE SEGURO",
            "color": "green",
            "riesgo": "Muy Bajo",
        }


def format_file_report(data):
    summary = data.get("analysis_summary", {})
    verdict = summary.get("risk_verdict", {})
    report = [
        f"--- VEREDICTO: {verdict.get('texto', 'N/A')} ---",
        "\n--- RESUMEN DEL ANÁLISIS ---",
        f"Score (Detecciones VT): {summary.get('score', 'N/A')}",
        f"Warnings (Imports sospechosos): {summary.get('warnings', 'N/A')}",
        "\n--- INFORMACIÓN DEL ARCHIVO ---",
        f"Filename: {data.get('filename', 'N/A')}",
        f"Size: {data.get('size_bytes', 0)} bytes ({data.get('size_kb', 0.0):.2f} KB)",
        f"Type: {data.get('type', 'N/A')}",
        f"Header (primeros 32 bytes): {data.get('header', 'N/A')}",
        f"Nombre representativo: {data.get('meaningful_name', 'N/A')}",
        f"Tipo de archivo (type_tag): {data.get('type_tag', 'N/A')}",
        f"Firma digital: {data.get('signature_info', 'N/A')}",
        f"Veces enviado a VT: {data.get('times_submitted', 'N/A')}",
    ]
    ptc = data.get("popular_threat_classification", {})
    threat = (
        ptc.get("suggested_threat_label", "N/A")
        if ptc and isinstance(ptc, dict)
        else "N/A"
    )
    report.extend(
        [
            f"Clasificación de amenaza: {threat}",
            f"TRiD: {data.get('trid', 'N/A')}",
            f"ExifTool: {data.get('exiftool', 'N/A')}",
            f"Etiquetas: {', '.join(data.get('tags', [])) if data.get('tags') else 'N/A'}",
            "\n--- HASHES ---",
            f"MD5:    {data.get('md5', 'N/A')}",
            f"SHA1:   {data.get('sha1', 'N/A')}",
            f"SHA256: {data.get('sha256', 'N/A')}",
            f"SHA512: {data.get('sha512', 'N/A')}",
        ]
    )
    malicious_vendors = data.get("malicious_vendors", [])
    if malicious_vendors:
        report.append("\n--- DETECCIONES DE PROVEEDORES ---")
        for v in malicious_vendors:
            report.append(f"- {v.get('vendor', 'N/A')}: {v.get('result', 'N/A')}")
    timing = data.get("timing", {})
    report.extend(
        [
            "\n--- METADATOS DEL ANÁLISIS ---",
            f"Versión del Script: {data.get('version', 'N/A')}",
            f"Análisis iniciado: {time.ctime(timing.get('started', 0))}",
            f"Análisis finalizado: {time.ctime(timing.get('finished', 0))}",
            f"Tiempo transcurrido: {timing.get('elapsed', 0.0):.4f} segundos",
        ]
    )
    # Sección opcional de imports PE detallados
    imports_grouped = data.get("imports")
    if imports_grouped and isinstance(imports_grouped, dict) and imports_grouped.keys():
        report.append("\n--- IMPORTS (PE) ---")
        for dll, funcs in imports_grouped.items():
            report.append(f"{dll} ({len(funcs)}):")
            for fn in funcs:
                report.append(f"  - {fn}")
    return "\n".join(report)


def resource_path(relative_path):
    base_path = getattr(
        sys,
        "_MEIPASS",
        os.path.abspath(os.path.join(os.path.dirname(__file__), "icons")),
    )
    return os.path.join(base_path, relative_path)


class SelectionFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color="transparent")
        self.master = master
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")

        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(
            relx=0.5, rely=0.1, relwidth=0.2, relheight=0.2, anchor="center"
        )

        self.title = ctk.CTkLabel(
            self,
            text="Seleccione el tipo de análisis",
            font=ctk.CTkFont(size=24, weight="bold"),
        )
        self.title.place(relx=0.5, rely=0.3, anchor="center")

        self.btn_doc = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar Documento\n (.docx,.pdf,.xlsx)",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=master.show_doc_entry_frame,
        )
        self.btn_doc.place(
            relx=0.5, rely=0.5, relwidth=0.4, relheight=0.2, anchor="center"
        )

        self.btn_file = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar Archivo \n (.exe,.zip,.bin)",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=master.show_file_entry_frame,
        )
        self.btn_file.place(
            relx=0.5, rely=0.8, relwidth=0.4, relheight=0.2, anchor="center"
        )


class FileEntryFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")
        self.file_path = ""
        self.volver_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("go_back.png")),
            dark_image=Image.open(resource_path("go_back(1).png")),
            size=(60, 40),
        )
        self.folder_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("favicon.ico")),
            dark_image=Image.open(resource_path("favicon.ico")),
        )
        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.entry_variable = ctk.StringVar(
            value="Inserte la ruta de un archivo o presione el botón para buscarlo..."
        )
        self.entry = ctk.CTkEntry(
            self, textvariable=self.entry_variable, border_width=1
        )
        self.button = ctk.CTkButton(
            self,
            image=self.folder_pic,
            text="",
            command=self.file_searching,
            width=50,
            border_width=1,
            fg_color=("#FF0000", "#FFFFFF"),
            hover_color=("#a10101", "#030227"),
        )
        self.file_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar...",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.start_analysis,
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.status_label = ctk.CTkLabel(self, text="", text_color=("blue", "cyan"))

        self.back_button = ctk.CTkButton(
            self,
            text="",
            image=self.volver_pic,
            command=master.show_selection_frame,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(relx=0.5, rely=0.2, anchor="center")
        self.entry.place(relx=0.05, rely=0.5, relwidth=0.8, relheight=0.1, anchor="w")
        self.button.place(relx=0.95, rely=0.5, relwidth=0.1, relheight=0.1, anchor="e")
        self.file_button.place(
            relx=0.5, rely=0.7, relwidth=0.2, relheight=0.15, anchor="center"
        )
        self.status_label.place(relx=0.5, rely=0.95, anchor="center")
        self.back_button.place(relx=0.01, rely=0.01, anchor="nw")

    def file_searching(self):
        self.file_path = filedialog.askopenfilename(
            title="Seleccionar archivo para análisis",
            filetypes=(
                ("Archivos Soportados", "*.exe *.dll *.zip *.rar *.7z"),
                ("Todos los archivos", "*.*"),
            ),
        )
        if self.file_path:
            self.entry_variable.set(self.file_path)
        else:
            self.entry_variable.set("No se seleccionó ningún archivo")

    def start_analysis(self):
        if not self.file_path or not os.path.exists(self.file_path):
            self.entry_variable.set("Por favor, seleccione un archivo válido.")
            return
        self.file_button.configure(state="disabled")
        self.button.configure(state="disabled")
        self.status_label.configure(text="Analizando, por favor espere...")
        self.master.start_file_analysis_thread(self.file_path)


class FileResultsFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=2, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.results = results
        self.place(relx=0.5, rely=0.5, relwidth=0.6, relheight=0.8, anchor="center")
        veredicto = self.results.get("analysis_summary", {}).get("risk_verdict", {})
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=2)
        ctk.CTkLabel(
            self,
            text="Resultados del Archivo",
            font=ctk.CTkFont(size=20, weight="bold"),
        ).grid(row=0, column=0, columnspan=2, pady=10, sticky="n")
        labels = [
            "Nombre del archivo:",
            "Tipo de archivo:",
            "Firma digital:",
            "Versión del archivo:",
            "Riesgo:",
            "Score de VirusTotal:",
        ]
        signature_info = self.results.get("signature_info")
        firma = (
            f"Sí (Autor: {signature_info.get('signers')})"
            if signature_info
            and isinstance(signature_info, dict)
            and signature_info.get("signers")
            else "No"
        )
        vt_score = self.results.get("analysis_summary", {}).get("score", 0)
        total_scans = self.results.get("total_scans", "N/A")
        values = [
            self.results.get("filename", "N/A"),
            self.results.get("type", "N/A"),
            firma,
            self.results.get("file_version", "N/A"),
            veredicto.get("riesgo", "N/A"),
            f"{vt_score}/{total_scans}",
        ]
        for i, (label, value) in enumerate(zip(labels, values)):
            ctk.CTkLabel(self, text=label, anchor="w").grid(
                row=i + 1, column=0, padx=20, pady=5, sticky="ew"
            )
            ctk.CTkLabel(self, text=value, anchor="w").grid(
                row=i + 1, column=1, padx=20, pady=5, sticky="ew"
            )
        ctk.CTkLabel(self, text="Detecciones de VirusTotal:", anchor="w").grid(
            row=7, column=0, padx=20, pady=(10, 0), sticky="ew"
        )
        detections_text = ctk.CTkTextbox(
            self,
            height=100,
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        detections_text.grid(
            row=8, column=0, columnspan=2, padx=20, pady=5, sticky="ew"
        )
        malicious_vendors = self.results.get("malicious_vendors", [])
        if malicious_vendors:
            for v in malicious_vendors:
                detections_text.insert(
                    "end", f"- {v.get('vendor', 'N/A')}: {v.get('result', 'N/A')}\n"
                )
        else:
            detections_text.insert("end", "0")
        detections_text.configure(state="disabled")
        self.grid_rowconfigure(9, weight=1)
        self.detail_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Análisis detallado",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.show_details,
        )
        self.refresh_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.detail_button.place(
            relx=0.3, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )
        self.refresh_button.place(
            relx=0.7, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )

    def show_details(self):
        self.destroy()
        self.master.show_detailed_file_frame(self.results)

    def refresh(self):
        self.destroy()
        self.master.show_file_entry_frame()


class DetailedFileFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=0, fg_color=("#ffffff", "#02005C"))
        self.master = master
        self.results = results
        self.place(relx=0.5, rely=0.5, relwidth=0.7, relheight=0.8, anchor="center")
        self.textbox = ctk.CTkTextbox(
            self,
            wrap="word",
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        self.textbox.pack(padx=10, pady=10, fill="both", expand=True)
        self.textbox.insert("0.0", format_file_report(self.results))
        self.textbox.configure(state="disabled")
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(fill="x", pady=10)
        self.txt_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar análisis a txt",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_txt,
        )
        self.json_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar análisis a json",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_json,
        )
        self.refresh_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.txt_button.pack(side="left", expand=True)
        self.json_button.pack(side="left", expand=True)
        self.refresh_button.pack(side="left", expand=True)

    def save_report(self, formato):
        if formato == "JSON":
            file_ext, file_types, content = (
                ".json",
                [("JSON files", "*.json")],
                json.dumps(self.results, indent=4, ensure_ascii=False),
            )
        else:
            file_ext, file_types, content = (
                ".txt",
                [("Text files", "*.txt")],
                format_file_report(self.results),
            )

        initial_filename = os.path.splitext(self.results["filename"])[0]

        save_path = filedialog.asksaveasfilename(
            initialfile=f"reporte_{initial_filename}",
            defaultextension=file_ext,
            filetypes=file_types,
        )
        if save_path:
            try:
                with open(save_path, "w", encoding="utf-8") as f:
                    f.write(content)
                messagebox.showinfo("Éxito", f"Reporte guardado en:\n{save_path}")
            except Exception as e:
                messagebox.showerror(
                    "Error al guardar", f"No se pudo guardar el archivo:\n{e}"
                )

    def save_txt(self):
        self.save_report("TXT")

    def save_json(self):
        self.save_report("JSON")

    def refresh(self):
        self.destroy()
        self.master.show_file_entry_frame()


# --- Clases de malware_app.py adaptadas ---
class DocEntryFrame(ctk.CTkFrame):
    def __init__(self, master):
        super().__init__(master, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.8, relheight=0.5, anchor="center")
        self.file_path = ""
        self.volver_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("go_back.png")),
            dark_image=Image.open(resource_path("go_back(1).png")),
            size=(60, 40),
        )
        self.folder_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("favicon.ico")),
            dark_image=Image.open(resource_path("favicon.ico")),
        )
        self.icon_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.png")),
            dark_image=Image.open(resource_path("logo (1).png")),
            size=(150, 150),
        )
        self.entry_variable = ctk.StringVar(
            value="Inserte la ruta de un documento o presione el botón para buscarlo..."
        )
        self.entry = ctk.CTkEntry(
            self, textvariable=self.entry_variable, border_width=1
        )

        self.button = ctk.CTkButton(
            self,
            image=self.folder_pic,
            text="",
            command=self.file_searching,
            width=50,
            border_width=1,
            fg_color=("#FF0000", "#FFFFFF"),
            hover_color=("#a10101", "#030227"),
        )
        self.file_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar...",
            border_width=2,
            command=self.next_frame,
            hover_color=("#a10101", "#030227"),
        )
        self.icon_button = ctk.CTkButton(
            self,
            text="",
            image=self.icon_pic,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.back_button = ctk.CTkButton(
            self,
            text="",
            image=self.volver_pic,
            command=master.show_selection_frame,
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.icon_button.place(relx=0.5, rely=0.2, anchor="center")
        self.entry.place(relx=0.05, rely=0.5, relwidth=0.8, relheight=0.1, anchor="w")
        self.button.place(relx=0.95, rely=0.5, relwidth=0.1, relheight=0.1, anchor="e")
        self.file_button.place(
            relx=0.5, rely=0.7, relwidth=0.2, relheight=0.15, anchor="center"
        )
        self.back_button.place(relx=0.01, rely=0.01, anchor="nw")

    def file_searching(self):
        self.file_path = filedialog.askopenfilename(
            title="Select a file",
            filetypes=[
                ("Documentos de Word", "*.docx"),
                ("Documentos pdf", "*.pdf"),
                ("Documentos excel", "*xlsx"),
                ("Todos los archivos", "*.*"),
            ],
        )
        if self.file_path:
            self.entry_variable.set(self.file_path)
        else:
            self.entry_variable.set("No se seleccionó ningún archivo")

    def next_frame(self):
        if self.file_path:
            self.destroy()
            self.master.show_doc_results_frame(self.file_path)
        else:
            self.entry_variable.set("No se seleccionó ningún archivo")


class DocResultsFrame(ctk.CTkFrame):
    def __init__(self, master, filepath):
        super().__init__(master, border_width=2, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.5, relheight=0.8, anchor="center")
        self.qs = quicksand(filepath)
        self.qs.process()
        self.qs.results["filename"] = os.path.basename(filepath)
        ctk.CTkLabel(
            self,
            text="Resultados del Documento",
            font=ctk.CTkFont(size=20, weight="bold"),
        ).place(relx=0.05, rely=0.05, anchor="nw")
        labels = [
            "Nombre del archivo:",
            "Riesgo:",
            "Advertencias:",
            "Tamaño del archivo:",
        ]
        values = [
            self.qs.results["filename"],
            self.qs.results["risk"],
            self.qs.results["warning"],
            f"{self.qs.results['size']} bytes",
        ]
        for i, (label, value) in enumerate(zip(labels, values)):
            ctk.CTkLabel(self, text=label).place(
                relx=0.05, rely=0.15 + i * 0.1, anchor="nw"
            )
            ctk.CTkLabel(self, text=value).place(
                relx=0.4, rely=0.15 + i * 0.1, anchor="nw"
            )
        self.button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Análisis detallado",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.analisis,
        )
        self.button.place(
            relx=0.25, rely=0.7, relwidth=0.3, relheight=0.1, anchor="center"
        )
        self.refresh_button = ctk.CTkButton(
            self,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.refresh_button.place(
            relx=0.7, rely=0.7, relwidth=0.32, relheight=0.1, anchor="center"
        )

    def analisis(self):
        self.destroy()
        self.master.show_detailed_doc_frame(self.qs.results)

    def refresh(self):
        self.destroy()
        self.master.show_doc_entry_frame()


class DetailedDocFrame(ctk.CTkFrame):
    def __init__(self, master, results):
        super().__init__(master, border_width=0, fg_color=("#ffffff", "#02005C"))
        self.place(relx=0.5, rely=0.5, relwidth=0.7, relheight=0.8, anchor="center")
        self.results = results

        self.textbox = ctk.CTkTextbox(
            self,
            wrap="word",
            fg_color=("#ffffff", "#02005C"),
            text_color=("#000000", "#FFFFFF"),
        )
        self.textbox.pack(padx=10, pady=10, fill="both", expand=True)
        self.textbox.insert("0.0", json.dumps(self.results, indent=4))
        self.textbox.configure(state="disabled")
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(fill="x", pady=10)
        self.txt_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar análisis a txt",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_txt,
        )
        self.json_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Pasar análisis a json",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.save_json,
        )
        self.refresh_button = ctk.CTkButton(
            button_frame,
            border_color=("#000000", "#FFFFFF"),
            fg_color=("#FF0000", "#02005C"),
            text_color=("#FFFFFF", "#FFFFFF"),
            text="Analizar otro archivo",
            border_width=2,
            hover_color=("#a10101", "#030227"),
            command=self.refresh,
        )
        self.txt_button.pack(side="left", expand=True)
        self.json_button.pack(side="left", expand=True)
        self.refresh_button.pack(side="left", expand=True)

    def save_report(self, formato):
        content = json.dumps(self.results, indent=4)
        file_ext = ".json" if formato == "JSON" else ".txt"
        file_types = (
            [("JSON files", "*.json")]
            if formato == "JSON"
            else [("Text files", "*.txt")]
        )

        initial_filename = os.path.splitext(self.results["filename"])[0]

        save_path = filedialog.asksaveasfilename(
            initialfile=f"reporte_{initial_filename}",
            defaultextension=file_ext,
            filetypes=file_types,
        )
        if save_path:
            try:
                with open(save_path, "w", encoding="utf-8") as f:
                    f.write(content)
                messagebox.showinfo("Éxito", f"Reporte guardado en:\n{save_path}")
            except Exception as e:
                messagebox.showerror(
                    "Error al guardar", f"No se pudo guardar el archivo:\n{e}"
                )

    def save_txt(self):
        self.save_report("TXT")

    def save_json(self):
        self.save_report("JSON")

    def refresh(self):
        self.destroy()
        self.master.show_doc_entry_frame()


class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Analizador de Malware")
        self.geometry("900x700")
        self.configure(fg_color=("#ffffff", "#02005C"))
        self.iconbitmap(resource_path("logo.ico"))
        self.current_frame = None

        # --- Botones de la ventana principal ---
        self.theme_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("sun.ico")),
            dark_image=Image.open(resource_path("moon.ico")),
        )
        self.logo_pic = ctk.CTkImage(
            light_image=Image.open(resource_path("logo.ico")),
            dark_image=Image.open(resource_path("logo2.ico")),
        )

        self.theme_button = ctk.CTkButton(
            self,
            width=0.1,
            height=0.2,
            text="",
            image=self.theme_pic,
            compound="left",
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
            command=self.change_theme,
        )
        self.theme_button.place(
            relx=1, rely=0, relwidth=0.05, relheight=0.05, anchor="ne"
        )

        self.logo_button = ctk.CTkButton(
            self,
            width=0.1,
            height=0.2,
            text="",
            image=self.logo_pic,
            compound="left",
            fg_color="transparent",
            hover_color=("#ffffff", "#02005C"),
        )
        self.logo_button.place(
            relx=0, rely=0, relwidth=0.05, relheight=0.05, anchor="nw"
        )

        self.show_selection_frame()

    def change_theme(self):
        if ctk.get_appearance_mode() == "Light":
            ctk.set_appearance_mode("Dark")
            self.iconbitmap(resource_path("logo2.ico"))
        else:
            ctk.set_appearance_mode("Light")
            self.iconbitmap(resource_path("logo.ico"))

    def clear_frame(self):
        for widget in self.winfo_children():
            if isinstance(
                widget,
                (
                    SelectionFrame,
                    FileEntryFrame,
                    DocEntryFrame,
                    FileResultsFrame,
                    DocResultsFrame,
                    DetailedFileFrame,
                    DetailedDocFrame,
                ),
            ):
                widget.destroy()
        if self.current_frame:
            self.current_frame.destroy()
            self.current_frame = None

    def show_selection_frame(self):
        self.clear_frame()
        self.current_frame = SelectionFrame(self)

    def show_file_entry_frame(self):
        self.clear_frame()
        self.current_frame = FileEntryFrame(self)

    def show_doc_entry_frame(self):
        self.clear_frame()
        self.current_frame = DocEntryFrame(self)

    def show_file_results_frame(self, results):
        self.clear_frame()
        self.current_frame = FileResultsFrame(self, results)

    def show_doc_results_frame(self, filepath):
        self.clear_frame()
        self.current_frame = DocResultsFrame(self, filepath)

    def show_detailed_file_frame(self, results):
        self.clear_frame()
        self.current_frame = DetailedFileFrame(self, results)

    def show_detailed_doc_frame(self, results):
        self.clear_frame()
        self.current_frame = DetailedDocFrame(self, results)

    def start_file_analysis_thread(self, filepath):
        thread = threading.Thread(target=self.run_file_analysis, args=(filepath,))
        thread.daemon = True
        thread.start()

    def run_file_analysis(self, filepath):
        start_time = time.time()
        try:
            all_hashes = calcular_hashes(filepath)
            if not all_hashes:
                raise Exception("No se pudieron calcular los hashes.")
            with open(filepath, "rb") as f:
                header_hex = f.read(32).hex()
            vt_results = consultar_virustotal(all_hashes["sha256"], lambda m: None)
            pe_info = analizar_pe(filepath, lambda m: None)
            veredicto = generar_veredicto(vt_results)
            analysis_result = {
                "filename": os.path.basename(filepath),
                "md5": all_hashes.get("md5"),
                "sha1": all_hashes.get("sha1"),
                "sha256": all_hashes.get("sha256"),
                "sha512": all_hashes.get("sha512"),
                "size_bytes": os.path.getsize(filepath),
                "size_kb": os.path.getsize(filepath) / 1024.0,
                "type": pe_info["type"],
                "file_version": pe_info.get("file_version", "N/A"),
                "num_imports": pe_info.get("num_imports", "N/A"),
                "imports": pe_info.get("imports", {}),
                "header": header_hex,
                "analysis_summary": {
                    "risk_verdict": veredicto,
                    "score": vt_results.get("malicious_detections", "N/A"),
                    "warnings": 0,
                },
                "total_scans": vt_results.get("total_scans", 0),
                **vt_results,
                "timing": {
                    "started": start_time,
                    "finished": time.time(),
                    "elapsed": time.time() - start_time,
                },
                "version": SCRIPT_VERSION,
            }
            self.after(0, self.show_file_results_frame, analysis_result)
        except Exception as e:
            self.after(0, lambda: messagebox.showerror("Error de Análisis", str(e)))
            self.after(0, self.show_file_entry_frame)


if __name__ == "__main__":
    ctk.set_appearance_mode("System")
    ctk.set_default_color_theme("blue")
    app = App()
    app.mainloop()
